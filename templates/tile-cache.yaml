---
AWSTemplateFormatVersion: '2010-09-09'

Description: 'CloudFront map tile cache'

Metadata:

  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: 'Settings'
        Parameters:
          - IncludeLambdaEdge
          - CloudFrontTTL
          - PriceClass
          - LogRetentionPeriod
    ParameterLabels:
      CloudFrontTTL:
        default: 'Cache TTL'
      IncludeLambdaEdge:
        default: 'Toggle Lambda Function'
      LogRetentionPeriod:
        default: 'Access Logs'
      PriceClass:
        default: 'Price Class'

Parameters:

  CloudFrontTTL:
    Description: |
      Number of seconds a page will be cached before returning new content
    Type: Number
    MinValue: 0
    Default: 300

  IncludeLambdaEdge:
    Description: 'Cache filling function'
    Type: String
    AllowedValues: ['true', 'false']
    Default: 'true'

  LogRetentionPeriod:
    Description: 'Number of days logs will be kept before deletion'
    Type: Number
    MinValue: 0
    Default: 365

  MapArn:
    Type: String
    Description: Arn of a Map resource
    AllowedPattern: '^arn:aws(.+)?:geo:.+'

  PriceClass:
    Description: |
      Edge cache locations - https://aws.amazon.com/cloudfront/pricing/
    Type: String
    AllowedValues: ['PriceClass_All', 'PriceClass_200', 'PriceClass_100']
    Default: 'PriceClass_100'

Conditions:

  IncludeLambdaEdge: !Equals [!Ref IncludeLambdaEdge, 'true']

Resources:

  TileCacheBucket:
    Type: 'AWS::S3::Bucket'
    DeletionPolicy: 'Retain'
    UpdateReplacePolicy: Retain
    Metadata:
      cfn_nag:
        rules_to_suppress:
          # S3 Bucket should have encryption option set
          - id: W41
            reason: Content is just a cache of public map tiles
    Properties:
      CorsConfiguration:
        CorsRules:
          - AllowedMethods:
              - GET
              - HEAD
            AllowedOrigins:
              - '*'
      LoggingConfiguration:
        DestinationBucketName: !Ref LoggingBucket
        LogFilePrefix: 'TileCacheBucket/'
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  TileCacheBucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    Properties:
      Bucket: !Ref TileCacheBucket
      PolicyDocument:
        Statement:
          - Effect: 'Allow'
            Action: 's3:GetObject'
            Resource: !Sub 'arn:aws:s3:::${TileCacheBucket}/*'
            Principal:
              CanonicalUser:
                - !GetAtt CloudFrontUser.S3CanonicalUserId

  LoggingBucket:
    Type: 'AWS::S3::Bucket'
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Metadata:
      cfn_nag:
        rules_to_suppress:
          # S3 Bucket should have access logging configured
          - id: W35
            reason: This bucket is a logging bucket
          # S3 bucket should likely have a bucket policy
          - id: W51
            reason: Using canned LogDeliveryWrite policy
    Properties:
      AccessControl: LogDeliveryWrite
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      LifecycleConfiguration:
        Rules:
          - Id: 'ExpireLogs'
            ExpirationInDays: !Ref LogRetentionPeriod
            Status: 'Enabled'
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  TileCachePolicy:
    Type: 'AWS::CloudFront::CachePolicy'
    Properties:
      CachePolicyConfig:
        DefaultTTL: !Ref CloudFrontTTL
        MaxTTL: 86400
        MinTTL: !Ref CloudFrontTTL
        Name: !Sub 'CachePolicy-${AWS::StackName}'
        ParametersInCacheKeyAndForwardedToOrigin:
          CookiesConfig:
            CookieBehavior: none
          EnableAcceptEncodingBrotli: true
          EnableAcceptEncodingGzip: true
          HeadersConfig:
            HeaderBehavior: whitelist
            Headers:
              - 'Access-Control-Request-Headers'
              - 'Access-Control-Request-Method'
              - 'Origin'
          QueryStringsConfig:
            QueryStringBehavior: none

  TileCacheCDN:
    Type: 'AWS::CloudFront::Distribution'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          # Cloudfront should use minimum protocol version TLS 1.2
          - id: W70
            reason: Using TLSv1.2_2018
    Properties:
      DistributionConfig:
        CacheBehaviors:
          - AllowedMethods:
              - GET
              - HEAD
            CachePolicyId: !GetAtt TileCachePolicy.Id
            Compress: true
            LambdaFunctionAssociations:
              - !If
                - IncludeLambdaEdge
                - EventType: 'origin-request'
                  LambdaFunctionARN: !Ref RequestHandlerFunctionVersion
                - !Ref 'AWS::NoValue'
            PathPattern: '*'
            TargetOriginId: S3TileCache
            ViewerProtocolPolicy: redirect-to-https
        DefaultCacheBehavior:
          ForwardedValues:
            QueryString: false
          TargetOriginId: S3TileCache
          ViewerProtocolPolicy: redirect-to-https
        Enabled: true
        HttpVersion: http2
        Logging:
          Bucket: !GetAtt LoggingBucket.DomainName
          Prefix: 'TileCacheCDN/'
        Origins:
          - DomainName: !GetAtt TileCacheBucket.DomainName
            Id: S3TileCache
            S3OriginConfig:
              OriginAccessIdentity: !Sub
                - 'origin-access-identity/cloudfront/${CloudFrontUser}'
                - {CloudFrontUser: !Ref CloudFrontUser}
        PriceClass: !Ref PriceClass
        ViewerCertificate:
          CloudFrontDefaultCertificate: true
          MinimumProtocolVersion: TLSv1.2_2018

  CloudFrontUser:
    Type: 'AWS::CloudFront::CloudFrontOriginAccessIdentity'
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: 'CloudFront user access to private tile cache bucket'

  RequestHandlerFunction:
    Type: 'AWS::Lambda::Function'
    Condition: IncludeLambdaEdge
    Properties:
      Handler: index.handler
      Role: !GetAtt RequestHandlerFunctionExecutionRole.Arn
      MemorySize: 128
      Timeout: 5
      Code:
        ZipFile: |
          # Start upgrade workaround ... remove when boto3 v1.17 is available
          import sys
          from pip._internal import main
          main(['install', '-I', '-q', 'boto3',
                '--target', '/tmp/', '--no-cache-dir',
                '--disable-pip-version-check'])
          sys.path.insert(0,'/tmp/')
          # End workarond

          import base64
          import boto3
          import json
          from urllib.parse import unquote

          geo = boto3.client('location')
          s3 = boto3.client('s3')

          def get_content_type(obj):
            ct = obj['ContentType']
            if ct and ct.strip():
              return ct
            return 'application/octet-stream'

          def handler(event, context):
              request = event['Records'][0]['cf']['request']

              # Remove the forward / from the uri
              key = request['uri'][1:]
              uri = key.split('/')
              request_type = uri[4]

              if request_type == 'tiles':

                  objFetch = geo.get_map_tile(
                      MapName=uri[3],
                      Z=uri[5],
                      X=uri[6],
                      Y=uri[7])

              elif request_type == 'sprites':

                  objFetch = geo.get_map_sprites(
                      FileName=uri[5],
                      MapName=uri[3])

              elif request_type == 'style-descriptor':

                  objFetch = geo.get_map_style_descriptor(MapName=uri[3])

              elif request_type == 'glyphs':

                  objFetch = geo.get_map_glyphs(
                      FontStack=unquote(uri[5]),
                      FontUnicodeRange=uri[6],
                      MapName=uri[3])

              body_content = objFetch['Blob'].read()
              content_type = get_content_type(objFetch)

              s3.put_object(Bucket='tile-cache-tilecachebucket-1jn1tscxg4uvw',
                        Key=key,
                        Body=body_content,
                        ContentType=content_type)

              body_content_b64 = base64.b64encode(body_content).decode('utf-8')

              return {
                  "statusCode": 200,
                  "headers": {
                      "Content-Type": json.dumps(content_type),
                  },
                  "body": json.dumps(body_content_b64),
                  "isBase64Encoded": True,
              }
      Runtime: python3.8

  RequestHandlerFunctionVersion:
    Type: 'AWS::Lambda::Version'
    Condition: IncludeLambdaEdge
    Properties:
      FunctionName: !Ref RequestHandlerFunction

  RequestHandlerFunctionExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      AssumeRolePolicyDocument:
        Statement:
          - Effect: 'Allow'
            Principal:
              Service:
                - 'lambda.amazonaws.com'
                - 'edgelambda.amazonaws.com'
                - 'replicator.lambda.amazonaws.com'
            Action: 'sts:AssumeRole'

  GetFunctionPolicy:
    Type: 'AWS::IAM::Policy'
    Condition: IncludeLambdaEdge
    Properties:
      Roles:
        - !Ref RequestHandlerFunctionExecutionRole
      PolicyName: 'GetFunction'
      PolicyDocument:
        Statement:
          - Effect: 'Allow'
            Action:
              - 'lambda:GetFunction'
              - 'lambda:EnableReplication*'
              - 'lambda:InvokeFunction'
            Resource: !Ref RequestHandlerFunctionVersion
          - Effect: 'Allow'
            Action:
              - 'geo:GetMap*'
            Resource: !Ref MapArn
          - Effect: 'Allow'
            Action:
              - 's3:PutObject'
            Resource:
              - !Sub 'arn:aws:s3:::${TileCacheBucket}/*'
